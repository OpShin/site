{"/user-manual/additional_resources":{"title":"Getting Started with Opshin","data":{"":"If you want to learn more about OpShin you can find additional resources at these points.","opshin-pioneer-program#OpShin Pioneer Program":"Check out the opshin-pioneer-program for a host of educational example contracts, test cases and off-chain code.","example-repository#Example repository":"Check out the opshin-starter-kit repository for a quick start in setting up a development environment\nand compiling some sample contracts yourself.You can replace the contracts in your local copy of the repository with code from the\nexamples section here to start exploring different contracts.","awesome-opshin#Awesome Opshin":"The \"Awesome Opshin\" repository contains a host of DApps, Tutorials and other resources written in OpShin or suitable for learning it.\nIt can be found in the awesome-opshin repository.","developer-community-and-questions#Developer Community and Questions":"This repository contains a discussions page.\nFeel free to open up a new discussion with questions regarding development using opshin and using certain features.\nOthers may be able to help you and will also benefit from the previously shared questions.Check out the community hereYou can also chat with other developers in the welcoming discord\ncommunity of OpShin\nHelp us improve OpShin by participating in this survey!","smart-contract-sizes#Smart Contract Sizes":"OpShin tries hard to make smart contracts smaller. We track the size of all example contracts in the main OpShin repository and publish a chart of the most recent releases here.If you have a smart contract that got significantly bigger or more expensive after a recent upgrade, please open an issue at the OpShin repository!","a-short-guide-on-writing-a-smart-contract#A short guide on Writing a Smart Contract":"A short non-complete introduction in starting to write smart contracts follows.\nMake sure you understand EUTxOs, Addresses, Validators etc on Cardano. There is a wonderful crashcourse by @KtorZ. The contract will work on these concepts\nMake sure you understand python. opshin works like python and uses python. There are tons of tutorials for python, choose what suits you best.\nMake sure your contract is valid python and the types check out. Write simple contracts first and run them using opshin eval to get a feeling for how they work.\nMake sure your contract is valid opshin code. Run opshin compile and look at the compiler erros for guidance along what works and doesn't work and why.\nDig into the examples to understand common patterns. Check out the prelude for understanding how the Script Context is structured and how complex datums are defined.\nCheck out the sample repository to find a sample setup for developing your own contract.\nIn summary, a smart contract in opshin is defined by the function validator in your contract file.\nThe function validates that a specific value can be spent, minted, burned, withdrawn etc, depending\non where it is invoked/used as a credential.\nIf the function fails (i.e. raises an error of any kind such as a KeyError or AssertionError)\nthe validation is denied, and the funds can not be spent, minted, burned etc.\nThere is a subtle difference here in comparison to most other Smart Contract languages.\nIn opshin a validator may return anything (in particular also False) - as long as it does not fail, the execution is considered valid.\nThis is more similar to how contracts in Solidity always pass, unless they run out of gas or hit an error.\nSo make sure to assert what you want to ensure to hold for validation!\nA simple contract called the \"Gift Contract\" verifies that only specific wallets can withdraw money.\nThey are authenticated by a signature.\nIf you don't understand what a pubkeyhash is and how this validates anything, check out this gentle introduction into Cardanos EUTxO.\nAlso see the tutorial by pycardano for explanations on what each of the parameters to the validator means and how to build transactions with the contract.Minting policies expect only a redeemer and script context as argument.\nCheck out the Architecture guide\nfor details on how to write double functioning contracts.\nThe examples folder contains more examples.\nAlso check out the opshin-pioneer-program\nand opshin-starter-kit repo.","the-small-print#The small print":"Not every valid python program is a valid smart contract.\nNot all language features of python will or can be supported.\nThe reasons are mainly of practical nature (i.e. we can't infer types when functions like eval are allowed).\nSpecifically, only a pure subset of python is allowed.\nFurther, only immutable objects may be generated.For your program to be accepted, make sure to only make use of language constructs supported by the compiler.\nYou will be notified of which constructs are not supported when trying to compile.You can also make use of the built-in linting command and check it for example with the following command:\nopshin lint spending examples/smart_contracts/assert_sum.py","name#Name":"Eopsin (Korean: 업신; Hanja: 業神) is the goddess of the storage and wealth in Korean mythology and shamanism.\n[...] Eopsin was believed to be a pitch-black snake that had ears. [1]\nSince this project tries to merge Python (a large serpent) and Pluto/Plutus (Greek wealth gods), the name appears fitting.\nThe name e_opsin is pronounced op-shin.\ne"}},"/user-manual/common_issues":{"title":"Common Issues when interacting with OpShin","data":{"recursionerror-maximum-recursion-depth-exceeded#RecursionError: maximum recursion depth exceeded":"This may happen when your contract is too large. Try setting the flag --recursion-limit to something high\nlike 2000. If it does not go away even with values above i.e. 10000, please open an issue.","the-contract-is-too-large-to-submit-in-a-transaction#The contract is too large to submit in a transaction":"OpShin provides various optimizations to decrease contract size. Most of these are already activated by default but a number of powerful optimizations can be added:\n-fdeduplicate is a powerful optimization that can reduce contract size significantly. It deduplicates low level terms, but is expensive, which is why it is disabled by default.\n-O3 enables a range of powerful optimizations (including -fdeduplicate) but also removes all error traces and print statements. This significantly reduces contract size but makes debugging much more difficult."}},"/user-manual/eutxo_crash_course":{"title":"eUTxO Crash Course","data":{"":"Note: This is based on an awesome guide by @Ktorz\nIf you have absolutely no idea what developing on Cardano looks like, worry\nnot. You just found the right piece to get started. Opshin is a language\nthat makes on-chain programming easy. But what is \"on-chain programming\" to\nbegin with? While this succinct documentation piece has no ambition to be a\ncomplete course on blockchains, it should give you enough insights to build a\nbasic understanding of the fundamentals.\nNote: This course will reference cryptography concepts such as hash\ndigests or digital signatures. We, therefore, expect readers to be either\nfamiliar with those concepts (at least a tiny bit) or to read up on them. There\nare plenty of resources available in the wild regarding cryptography and this\ncrash course isn't one of them.","blocks--transactions#Blocks & transactions":"Blockchains are made of blocks. And blocks are made of transactions. Without\ngoing into the details, you can think of blocks as being objects divided into\ntwo parts: a header and a body. The header contains information about the\nblocks, such as who produced them and when they were made. The body is nothing\nmore than an ordered sequence of transactions.Note that the \"chain\" of blockchain comes from how blocks reference one\nanother. Indeed, each block header includes at least two things:\nA hash digest of the block body\nA hash digest of the previous block header\n┏━ Header ━━━━━━━━━━━━━━┳━ Body ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃                       ┃                                           ┃\n┃  Body hash            ┃ ┌────────────────┬────────────────┬─────┐ ┃\n┃  Previous header hash ┃ │ Transaction #1 │ Transaction #2 │ ... │ ┃\n┃  Timestamp            ┃ └────────────────┴────────────────┴─────┘ ┃\n┃                       ┃                                           ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\nA hash digest is a tamper-proof mechanism that maps an input value to a\nfixed-sized output. Think of it as a way to assign an identifier to a piece of\ncontent, such that the identifier depends on the content itself: change the\ncontent, change the identifier.A chain is formed by including in every block header:\na hash of the block body; and\na header hash of the previous block.\nChanging any transaction in a block will change the block body hash, thus\nchanging the block header hash, the header hash of the next block, and so on,\ninvalidating the entire chain that follows.\n        ____          ____          ____          ____          ____\n       /    /\\       /    /\\       /    /\\       /    /\\       /    /\\\no ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ❮❮  /____/  \\ ...\n      \\    \\  /     \\    \\  /     \\    \\  /     \\    \\  /     \\    \\  /\n╿      \\____\\/       \\____\\/       \\____\\/       \\____\\/       \\____\\/\n│\n│                                     ╿\n│                                     │\n└ Genesis configuration               │\n                                      └ Block\nA transaction is, therefore, the most fundamental primitive on blockchains.\nThey are the mechanism whereby users (a.k.a you) can take actions to change the\nstate of the blockchain. A chain starts from an initial state typically\nreferred to as genesis configuration. And from there, transactions map a\nprevious state into a new state. Finally, blocks are merely there to batch\ntransactions together.","unspent-transaction-outputs#Unspent Transaction Outputs":"In the traditional database world, a transaction is a means to bundle\ntogether a series of atomic operations so that all are successful or none\nhappen. In the financial world, it is a way to transfer assets from one\nlocation to another.In the blockchain world, it is a bit of both.A transaction is, first and foremost, an object with an input from where it\ntakes assets and an output to where it sends them. Often, as is the case in\nCardano, transactions have many inputs and many outputs. And, in addition to\ninputs and outputs, blockchain protocols often include other elements that\nmodify different parts of the blockchain state (e.g. delegation certificates,\ngovernance votes, user-defined assets definitions...)Moreso, like in the database world, a transaction is an all-or-nothing atomic\nseries of commands. Either it is valid, and all its changes are applied, or it\nisn't, and none are applied.We'll talk more about other capabilities later. For now, let's focus on inputs\nand outputs, starting with the outputs.","outputs#Outputs":"In Cardano, an output is an object that describes at least two things:\na quantity of assets -- also known as, a value;\na condition for spending (and/or delegating) those assets -- also known as an address.\nIn addition, a data payload can also be added to outputs but let's not bother\nwith that just now. The role of the value is pretty transparent, and it\nindicates how many assets hold the output.Incidentally, Cardano supports two kinds of assets: the main protocol currency\n(a.k.a. Ada); and user-defined currencies. Both live side-by-side in values\nthough slightly different rules apply to each.The address captures the logic that tells the protocol under what conditions\none can utilize the assets at a particular output. It is what defines ownership\nof the assets. We'll explore this very soon. Bear with us a little more.\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃         ┃           ┃                ┃\n┃  Value  ┃  Address  ┃  Data payload  ┃\n┃         ┃           ┃                ┃\n┗━━━━━━━━━┻━━━━━━━━━━━┻━━━━━━━━━━━━━━━━┛","inputs#Inputs":"An input is a reference to a previous output. Think of outputs as post-it notes\nwith a unique serial number and inputs as being this serial number.A transaction is a document indicating which post-it notes should be destroyed\nand which new ones should be pinned to the wall. Note that there are rules\nregarding the construction of transactions. For example. there must as much\nvalue in as there's value out. Said differently, the total value should balance\nout but might be shuffled differently.An output that hasn't been spent yet (i.e. is still on the wall) is called --\nyou guessed it -- an unspent transaction output, or UTxO in short. The\nblockchain state results from looking at the entire wall of post-it remaining\nnotes. It includes not only the available UTxO, but also any additional data\ndefined by the protocol.Okay, back to inputs.Technically speaking, an input's \"serial number\" is the hash digest of the\ntransaction that emitted the output it refers to and the position of the output\nwithin that transaction. These two elements make each input unique. And because\noutputs are removed from the available set (post-it note is destroyed) when\nspent, they can only be spent once. At least, that's what the blockchain\nprotocol makes sure of.\n┏━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃                    ┃                ┃\n┃  Transaction hash  ┃  Output index  ┃\n┃                    ┃                ┃\n┗━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━┛\nWhere do the first outputs come from?If you've carefully followed the narrative we just went through, you might have\nrealized that we have a chicken-and-egg situation. Inputs are references to\noutputs. And outputs are created by spending inputs.This is what the genesis configuration is for. It defines the starting point of\nthe blockchain in the form of an agreed-upon initial list of outputs. Those\noutputs can be referred to using some special identifiers. For example, the\ngenesis configuration hash digest and the output's position in the\nconfiguration.","tldr#TL;DR":"Let's quickly recap what we've seen so far:\nA blockchain has an initial state called a genesis configuration;\nA transaction captures instructions to modify that state (e.g. transfer of assets);\nA block batches transactions together and has a reference to a parent block;\nAssets movement are expressed using inputs and outputs in transactions;\nAn output is an object with at least an address and a value;\nAn address describes the conditions needed to use the value associated to it;\nAn input is a reference to a previous output.","addresses#Addresses":"","overview#Overview":"It is now time to delve more into Cardano addresses. A typical address is made\nof 2 or 3 parts:\n┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃          ┃                       ┃                          ┃\n┃  Header  ┃  Payment credentials  ┃  Delegation credentials  ┃\n┃          ┃                       ┃                          ┃\n┗━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━┛\nWe said 2 or 3 because the last part -- the delegation credentials -- is\noptional. The first part is called the Header, and it describes the type of\naddress (i.e. what comes next) and the network within which this address can be\nused. We call that last bit a network discriminant and it prevents silly\nmistakes like sending real Mainnet funds to a test address. An address is\nrepresented as a sequence of bytes, usually encoded using\nbech32\nor simply base16 text strings.For example:\nor alternatively\nWe can dissect the latter text string to make the three parts mentionned above more apparent:\n               Type = 3 ┐┌ Network = 1 (1 = mainnet, 0 = testnet)\n                        ││\n                        ╽╽\nHeader:                 31\nPayment credentials:    \nDelegation credentials: \nAs we can see, this address is a type 3, is for mainnet and uses the same\ncredentials for both the payment and the delegation part.\nYou will often need to convert back-and-forth between bech32-encoded strings\nand hex-encoded strings. A great command-line tool for working with bech32 can\nbe found at\ninput-output-hk/bech32.\nUse it!","payment-credentials#Payment credentials":"The next part is the payment credentials, also called the payment part.\nThis is what describes the spending conditions for the address. Remember how\nUTxOs are like post-it notes on a wall? Yet you don't get to hang them or pick\nthem up directly yourself. You have to hand over a transaction to the network\nvalidators. Imagine an employee who's gatekeeping the wall of post-it notes and\nto whom you must give a form that describes what you want to do. Each post-it\nnote has written on it the conditions one must meet to pick it up and destroy\nit. That's what the payment credentials are for in the address. They come in\none of two forms:\na verification key hash digest; or\na script hash digest.\nIn the first form, the validator nodes -- or the employee -- will ask you to\nprovide a digital signature from the signing key corresponding to the\nverification key. This approach relies on asymmetric cryptography, where one\ngenerates credentials as a public (verification) and private (signing) key\npair. In the address, we store only a hash digest of the verification key for\nconciseness and to avoid revealing it too early (even though it is public\nmaterial). When spending from such an address, one must reveal the public key\nand show a signature of the entire transaction as witnesses (a.k.a proofs).\nThis way of specifying spending conditions is relatively straightforward but\nalso constrained because it doesn't allow for expressing any elaborate logic.This is where the second form gets more interesting. Cardano allows locking\nfunds using a script representing the validation logic that must be satisfied\nto spend funds guarded by the address. We typically call such addresses:\nscript addresses. Similarly to the first form, the entire script must be\nprovided as a witness by any transaction spending from a script address, as\nwell as any other elements required by the script. Scripts are like predicates.\nSaid differently, they are functions that return a boolean value: True or\nFalse. To be considered valid, all scripts in a transaction must return\nTrue. We'll explore how this mechanism works in a short moment.","delegation-credentials#Delegation credentials":"Addresses may also contain delegation credentials, also called a delegation\npart. We will only go a little into the details but think of the delegation\ncredentials as a way to control what can be done with the stake associated with\nthe address. The stake corresponds to the Ada quantity in the output's value\nthat the consensus protocol counts to elect block producers. In Cardano,\nthe stake can be delegated to registered entities called stake pools. By\ndelegating, one indicates that the stake associated with an output should be\ncounted as if it belonged to the delegatee, increasing their chance of\nproducing a block. In return, the delegatee agrees to share a portion of their\nblock-producing rewards with the delegator.While the payment credentials control how to spend an output, delegation\ncredentials control two separate operations:\nhow to publish a delegation certificate (e.g. to delegate stake to a stake pool);\nhow to withdraw rewards associated with the stake credentials.\nLike payment credentials, delegation credentials comes in two forms: as\nverification key hash digest or as script hash digest.\nMore information about addresses and how they work can be found in\nCIP-0019","tldr-1#TL;DR":"┌ For spending\n                        │\n                        ╽\n┏━ Header ━━━━━━━━━━━━━┳━ Payment credentials ━━━━━━━┳━ Delegation credentials ━━━━┓\n┃                      ┃                             ┃                             ┃\n┃                      ┃  ┌───────────────────────┐  ┃  ┌───────────────────────┐  ┃\n┃  ┌──────┬─────────┐  ┃  │ Verification key hash │  ┃  │ Verification key hash │  ┃\n┃  │ Type │ Network │  ┃  ├────────── OR ─────────┤  ┃  ├────────── OR ─────────┤  ┃\n┃  └──────┴─────────┘  ┃  │      Script hash      │  ┃  │      Script hash      │  ┃\n┃                      ┃  └───────────────────────┘  ┃  └───────────────────────┘  ┃\n┃                      ┃                             ┃                             ┃\n┗━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n                                                      ╿\n                                                      │\n                                                      └ For:\n                                                          - publishing certificates\n                                                          - withdrawing rewards\nBefore we move on, let's recap again:\nAn address is made of 2 or 3 parts: a header, payment credentials and delegation credentials;\nThe header describes the type of address and the network it is for;\nThe last part, the delegation credentials, is optional though highly recommended;\nCredentials (payment or delegation) take one of two forms:\na verification key hash;\na script hash;\nPayment credentials control how to spend from an address;\nDelegation credentials control how to publish certificates and how to withdraw rewards;\nA script allows the definition of arbitrary validation logic.","scripts-datums-and-redeemers#Scripts, Datums and Redeemers":"","overview-1#Overview":"Hang in there! We are almost at the end of this crash course. We've seen what a\nUTxO is what an address is made of. And we spoke a bit about scripts. In\nparticular, we said that scripts are like predicates, that is, pure functions\n(in the Mathematical sense) that takes a transaction as an argument and return\neither True or False.Well, not exactly. We lied to you (only a tiny bit).If we only had that, it would be hard to express more elaborate logic. In\nparticular, capturing a state, which programs often require, would be\ninfeasible. A state and transitions from that state. This is where the\nextended UTxO model strikes in. It adds two new components to what we've\nalready seen: datums and redeemers.We mentioned the datum earlier without calling it a datum when we said that\noutputs contained a value, an address and a data payload. This is what the\ndatum is, a free payload that developers can use to attach data to script\nexecution. When a script is executed in a spending scenario, it receives not\nonly the transaction as context but also the datum associated with the output\nbeing spent.The redeemer, on the other hand, is another piece of data that is also provided\nwith the transaction for any script execution. Notice that the datum and\nredeemer intervene at two distinct moments. A datum is set when the output is\ncreated (i.e. when the post-it note is hung on the wall, it is part of the\nnote). Whereas the redeemer is provided only when spending the output (i.e.\nwith the form handed over to the employee).","analogy#Analogy":"Another way to look at scripts, datums and redeemers is to think of them as a\nparameterised mathematical function.\n             Script\n          ╭─────────╮\n    f(x) = x * a + b  = true | false\n           ╿   ╿   ╿\n  Redeemer ┘   │   │\n               └─┬─┘\n               Datum\nThe script defines the function as a whole. It indicates how the parameters and\narguments are combined to produce a boolean outcome. The datum corresponds to\nthe parameters of the function. It allows configuring the function and\nre-using a similar validation logic with different settings. Both the function\nand the parameters are defined when assets are locked in an output. Which\nleaves only the function argument to be later provided. That argument is the\nredeemer (as well as the rest of the transaction).This is why scripts are often referred to as validators. Unlike some other\nblockchain systems, they are also, therefore, fully deterministic. Their\nexecution only depends on the transaction they're involved with, and evaluating\nthe transaction's outcome is possible before sending it to the network. Datums\nact as local states, and redeemers are user inputs provided in the transaction\nitself.\nIf we take a step back and look at the typical public/private key procedure for\nspending funds, we can see how eUTxO is merely a generalization of that.\nIndeed, the public key (hash) can be seen as the datum, whereas the signature\nis the redeemer. The script is the digital signature verification algorithm\nthat controls whether the signature is valid w.r.t the provided key.","purposes#Purposes":"So far, we've mostly talked about scripts in the context of validating whether\nan output can be spent. We've also briefly mentioned earlier how scripts can be\nused to control the publication of delegation certificates or how consensus\nrewards can be withdrawn.These different use cases are commonly referred to as script purposes. Until\nnow, we've seen three purposes: spend, publish and withdraw. There's a\nfourth one: mint.The mint purpose refers to scripts that are executed to validate whether\nuser-defined assets can be minted (i.e. created) or burned (i.e. destroyed).\nCardano indeed supports user-defined assets which are used to represent both\nfungible quantities (like a protocol currency) or non-fungible quantities\n(a.k.a NFTs).The rules that govern the creation or destruction of an asset are defined as a\nscript. We often refer to such scripts as minting policies, which correspond\nto the mint purpose above.Each purpose, therefore, indicates for what purpose a script is being\nexecuted. During validation, that information is passed to the script alongside\nthe transaction and the redeemer. Note that only scripts executed with the\nspend purpose are given a datum. This is because they can leverage the data\npayload present in outputs, unlike the other purposes that do not get this\nopportunity.","tldr-2#TL;DR":"And we've reached the end of this crash course. Let's do a final recap\nregarding scripts, datums and redeemers.\nScripts are akin to parameterized predicate functions, returning either true or false.\nDatums take the role of function parameters, whereas redeemers the one of argument.\nScripts are also called validators and are completely deterministic.\nScripts are used to validate specific operations in a transaction.\nWhat a script is used for is referred to as its purpose. There are 4 purposes:\nspend -- controls how to spend outputs;\npublish -- controls how to publish delegation certificates;\nwithdraw -- controls how to withdraw consensus rewards;\nmint -- controls how to mint or burn assets.\nOnly spending scripts (i.e. purpose=spend) have access to a datum."}},"/user-manual/getting_started":{"title":"Getting Started with Opshin","data":{"prequisites#Prequisites":"This guide tries to assume as little knowledge as possible but there are certain assumptions:\nYou should understand Python. Opshin is basically Python so we assume some basic knowledge of Python.","installation#Installation":"Install Python 3.9 to 3.13.\nThen run:\npython3 -m pip install opshin","compiling-opshin-code#Compiling Opshin Code":"Make a file called hello_world.py and copy:\n# hello_world.py\nfrom opshin.prelude import *\ndef validator(_: ScriptContext) -> None:\n    print(\"Hello world!\")\nRun this command:\nopshin build hello_world.py\nThis should create a build folder in the current directory.\nThe build folder should look like this:\nbuild/\n  └-hello_world/\n    ├-mainnet.addr\n    ├-script.cbor\n    ├-script.plutus\n    ├-script.policy_id\n    └-testnet.addr\nWe'll cover what all these files in the hello_world sub-folder mean later in the book."}},"/user-manual":{"title":"Introduction","data":{"what-is-opshin#What is OpShin?":"Opshin is a pythonic language for writing smart contracts on the Cardano blockchain.\nThe goal of Opshin is to reduce the barrier of entry in Smart Contract development on Cardano.\nOpshin is a strict subset of Python, this means anyone who knows Python can get up to speed on Opshin pretty quickly.","what-is-a-smart-contract-on-cardano#What is a Smart Contract on Cardano?":"On Cardano, funds are stored at addresses. An address can be controlled by a cryptographic key, the secret for unlocking it being only known\nto a specific user.\nThe alternative is a Smart Contract - this is some encoded logic that controls unlocking funds from the address.\nIn particular, this logic just validates that funds may be unlocked from the address based on how they are spent. For this reason,\nthis kind of smart contract is often referred to as Spending Validator.Other contracts also exist i.e. to validate minting of native tokens, withdrawal of stake rewards or certification of stake pools.","sample-code#Sample Code":"The following contract validates that the signature of a special user is present in a transaction.\nThe signature is specified by a third party and attached to an UTxO sent to the contract.\nThe receiver can then construct a transaction where they unlock the funds from the contract.\nThe contract allows this when it is provided the signature of the receiver.\n# gift.py\nfrom opshin.prelude import *\n@dataclass()\nclass WithdrawDatum(PlutusData):\n    pubkeyhash: bytes\ndef validator(context: ScriptContext) -> None:\n    datum: WithdrawDatum = own_datum_unsafe(context)\n    sig_present = False\n    for s in context.tx_info.signatories:\n        if datum.pubkeyhash == s:\n            sig_present = True\n    assert sig_present, \"Required signature missing\"","why-opshin#Why opshin?":"100% valid Python. Leverage the existing tool stack for Python, syntax highlighting, linting, debugging, unit-testing, property-based testing, verification\nIntuitive. Just like Python.\nFlexible. Imperative, functional, the way you want it.\nEfficient & Secure. Static type inference ensures strict typing and optimized code.\nWe thank our generous supporters!"}},"/user-manual/language_tour/builtins":{"title":"Builtins","data":{"":"A growing list of the Python builtin functions is being implemented in OpShin.\nIt will be documented here.","allx-listbool---bool#all(x: List[bool]) -> bool":"Returns whether all booleans in a list are True.","anyx-listbool---bool#any(x: List[bool]) -> bool":"Returns whether any of the booleans in a list is True.","absx-int---int#abs(x: int) -> int":"Returns the absolute value of an integer.","bytesx-int---bytes#bytes(x: int) -> bytes":"Returns a bytestring with 0s of length x.","bytesx-listint---bytes#bytes(x: List[int]) -> bytes":"Returns a bytestring where every byte corresponds to one integers in x.","chrx-int---str#chr(x: int) -> str":"Returns the character for unicode code point x.","hexx-int---str#hex(x: int) -> str":"Returns the hexadecimal representation of an integer.","lenx-unionbytes-listanything---int#len(x: Union[bytes, List[Anything]]) -> int":"Returns a the length of x for bytes and lists.","maxx-listint---int#max(x: List[int]) -> int":"Returns the maximum of all integers in a list.","minx-listint---int#min(x: List[int]) -> int":"Returns the minimum of all integers in a list.","octx-int---str#oct(x: int) -> str":"Returns the octal representation of an integer.","powx-int-y-int---str#pow(x: int, y: int) -> str":"Returns xy","rangex-int---listint#range(x: int) -> List[int]":"Returns the integers from 0 to x-1 as a list.","reversedx-listanything---listanything#reversed(x: List[Anything]) -> List[Anything]":"Returns the reversal of list x.","strx-anything---str#str(x: Anything) -> str":"Returns a stringified representation of x.","sumx-listint---int#sum(x: List[int]) -> int":"Returns the sum of all integers in a list."}},"/user-manual/language_tour/classes":{"title":"Custom Classes","data":{"":"If you want to define a custom class to be used in Opshin, it must be a dataclass which inherits from the PlutusData class which can be imported from opshin.prelude.\nfrom opshin.prelude import *\n@dataclass()\nclass Person(PlutusData):\n    # Every person has a UTF8 encoded name\n    name: bytes\n    # Every person has a year of birth\n    birthyear: int\nPlutusData may contain only bytes, int, dicts, lists or other dataclasses.\nNote that str and None are not valid field types of PlutusData.","constructing-objects#Constructing objects":"You can construct an object by calling the classname with the variables in order defined in the class.\na = Person(b\"Billy\", 1970)","attribute-access#Attribute access":"All named attributes defined in the class body are accessible\nby object.attribute. For example, to access the name of a person we would run\nprint(a.name)  # prints b\"Billy\"","union-types#Union types":"It may happen that you allow more than a single type of data for your application (think of a Smart Contract that allows different operations on it).\nIn this case, you may define a Union[A, B, ...] type.\nThis expresses that a variable may be of either of the classes inside the square brackets.\n@dataclass()\nclass Plant(PlutusData):\n    CONSTR_ID = 1\n    # Plants have no further properties\n@dataclass()\nclass Animal(PlutusData):\n    CONSTR_ID = 2\n    # Animals have a name too!\n    name: bytes\n    # They also have an owner, which is another dataclass\n    owner: Person\n# Note all of these classes have distinct CONSTR_ID values\nCityDweller = Union[Animal, Plant, Person]\n# Both assignments are fine, because a is annotated\n# to be of the Union type and can be of either class\nc: CityDweller = Plant()\nc = Animal(b\"jackie\", a)\nImportantly, you need to set the CONSTR_ID of Classes that occur in a Union to distinct values.\nOn-Chain, classes are only distinguished by their CONSTR_ID value.\nIf omitted, the CONSTR_ID defaults to an almost-unique determinstic value based on the Class definition.","type-casts#Type casts":"If a variable is of an Union type we may still want to distinguish how we handle them\nbased on the actual type.\nFor this, we can use the function isinstance.\nisinstance(x, A) returns True if value x is an instance of class A (which is not a Union type!).\n# this is forbidden!\n# If a is a Plant or Animal, it does not have a birthyear so this operation will fail.\nprint(a.birthyear)\nif isinstance(a, Person):\n    # Here its okay\n    # OpShin recognizes the isinstance check and knows that\n    # a is of type Person in this branch of the condition\n    print(a.birthyear)\nWe can combine isinstance calls and access shared attributes across classes.\nif isinstance(a, Person) or isinstance(a, Animal):\n    # a is of type Union[Person, Animal] in this branch\n    # Both classes have the same attribute at the same position\n    # so we can access it in either case\n    print(a.name)\nYou can also form the complement of type casts.\na: Union[Person, Animal] = ...\nif isinstance(a, Person):\n    # a is of type Person in this branch\n    print(a.birthyear)\nelse:\n    # a is of type Animal in this branch\n    print(a.owner)\nNote that you can also use str / print directly to get a very informative representation of the object\nprint(a)\n# \"Person(name=b'Billy', birthyear=1970)\"","to_cbor#.to_cbor()":"To obtain the CBOR representation of an object, you may call its to_cbor method.\nThis will return the bytes representing an object in CBOR.\nprint(a.to_cbor().hex())\n# prints \"d8799f4542696c6c791907b2ff\""}},"/user-manual/language_tour/conditional_statements":{"title":"Conditional Statements","data":{"":"Opshin uses if, elif and else statements for conditional control flow.\nelif is a short form of else if and behaves like you would expect it.","if#if":"n = 4\nif n < 5:\n    print(\"Less than 5.\")\nelif n == 5:\n    print(\"Equal to 5.\")\nelse:\n    print(\"Greater than 5.\")","pass#pass":"This statement does not do anything.\nIt is mainly used to show the compiler that you respect an indent for an otherwise\nempty control flow branch.\nif check:\n    pass\nelse:\n    some_important_function()","assert#assert":"The assert statement is an important tool in Smart Contracts to check\nthat conditions of the contract are met.\nIt checks that a statement is correct and otherwise immediately halts the contract\nwith an error message if provided.\nassert money_locked_in_contract >= 100000, f\"Expected 100000 but only received {money_locked_in_contract}\"\nSemantically it can be imagined like this:\nif condition_met:\n    pass\nelse:\n    print(error_message)\n    <fails contract>\nInformative error messages will save you plenty of time when executing and debugging\nyour off-chain transactions."}},"/user-manual/language_tour/container_types":{"title":"Container Types","data":{"":"Opshin has two main container types, lists and dicts:\nList[a]\nDict[k, v]\nNote: The container types are generic, and the letter in square brackets ([]) are the type arguments\nThey come in handy if you want to handle large amounts of values of the same type.","lista#List[a]":"The Opshin List type is a container type that is used to hold multiple values of the same type.\nThis is works just like the list type in Python. In particular, you simply place all values in the desired order into the list.\nFor example, for a list of integers from 1 to 5, you can write the following:\nlisty: List[int] = [1, 2, 3, 4, 5]\nIf you omit the type annotation, OpShin will attempt to derive the most precise type that applies to all values in the list.\nFor example, if you specify [1, \"hellooo\"], it will derive the type List[Union[str, int]].","list-operations#List Operations":"You can add lists using the + operator.\nprint([1, 2, 3, 4] + [5, 6])\n# prints \"[1, 2, 3, 4, 5, 6]\"","list-access#List Access":"You may access elements at arbitrary positions within a list like this:\nlisty[3]  # will return the element at the 4th position (3rd with 0-based indexing), i.e. 4\nIf you want to count from the back, use negative numbers:\nlisty[-2]  # returns the second-to-last element, i.e. 4\nNote: In contrast to Python lists, which have constant time index access, Opshin lists are actually linked-lists and access time is linear to their size.\nThis is because that's how lists are implemented in UPLC.","list-slices#List Slices":"You may access slices of a list using the slicing syntax.\n[\"a\", \"b\", \"c\", \"d\"][1:3]  # returns [\"b\", \"c\"]","list-comprehension#List Comprehension":"Opshin supports Python's list comprehension syntax.\nThis allows for very compact list initialization:\nsquares = [x**2 for x in listy]","lenx#len(x)":"The len method returns the length of the list as an int:\nlenny: int = len(listy) \nlenny == 5  # True","membership-using-in#Membership using in":"You can check whether some element is included in a list of elements using the keyword in.\n4 in [1, 2, 3, 4, 5]  # True\n100 in range(10)  # False","empty-lists#Empty lists":"Since OpShin will try to infer the type of the list automatically based on its content, empty lists pose a special challenge.\nIf you omit the type annotation on an empty list literal, it will be assigned type List[Anything].\nThat means you can not do any sensible operations on values in the list.\nIf you need an empty list of a specific type, initialize it in a typed assignment.\nempty_list_any = []  # has type List[Anything]\nempty_list_any + [1]  # Fails type check: can not concatenate list of type int and Anything\nempty_list_int: List[int] = []  # has type List[int]\nempty_list_int + [1]  # works fine","dictk-v#Dict[k, v]":"The Dict type represents a map from keys of type k to values of type v.\nIt works just like the dict type in Python.\n# A dictionary storing scores in a game.\nscores: Dict[str, int] = {\"god_binder\": 12, \"radio_knight\": 42}\nJust as for lists, OpShin automatically derives precise key and value types.","dictionary-access#Dictionary Access":"A dictionary implements a map. In order to find the mapped value of element x we can\naccess it in the dictionary via dict[x].\nscores[\"god_binder\"]  # returns 12\nTake care when accessing values that are not contained in the dictionary -\nin case of missing keys, the contract will fail immediately.\nscores[\"peter_pan\"]  # fails with \"KeyError\"\nIf you are not sure whether a key maps to something in the dictionary\nuse dict.get(x, d). It will try to return the value mapped to by x in the dictionary.\nIf x is not present it will return d.\nIt is important that d is of the value type v to guarantee type safety.\nscores.get(\"god_binder\", 0)  # returns 12\nscores.get(\"peter_pan\", 0)  # returns 0\nNote: Random access to dictionaries in OpShin has cost linear in the size of the dictionary instead of constant, due to the nature of the underlying target language UPLC.","keys#.keys()":"The .keys() method returns a list of the keys in a dictionary,\nplayers: List[str] = scores.keys() # [\"god_binder\", \"radio_knight\"]","values#.values()":"The .values() method returns a list of all the values in a dictionary.\nraw_scores: List[int] = scores.values() # [12, 42]","items#.items()":"The .items() method returns a tuple of the each key-value pair in the dictionary.\nThis is particularly useful if you want to iterate over all pairs contained in a dictionary.\nfor username, score in scores.items():\n    print(f\"{username} scored: {score}\")\n    # prints first \"god_binder scored: 12\" and then \"radio_knight scored: 42\"","empty-dicts#Empty dicts":"As with lists, empty dictionaries pose a special challenge.\nIf you omit the type annotation on an empty dictionary literal, it will be assigned type Dict[Anything, Anything].\nThat means you can not do any sensible operations on values in the dict, and .get() will return values of type Anything.\nIf you need an empty dictionary of a specific type, initialize it in a typed assignment.\nempty_dict_any = {}  # has type Dict[Anything, Anything]\nempty_dict_any.get(\"hi\", 1) + 2  # Fails type check: can not add types int and Anything\nempty_dict_int: Dict[str, int] = {}  # has type Dict[str, int]\nempty_dict_int.get(\"hi\", 1) + 2  # works!"}},"/user-manual/language_tour/functions":{"title":"Functions","data":{"regular-functions#Regular Functions":"Functions in Opshin should have type annotations for the arguments and the return value.\nReturn statements can be placed anywhere inside a function.\nNote that all return statements must have a type compatible with the annotated\nreturn type.\ndef fibonacci(n: int) -> int:\n    if n < 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\nA function foo is called as foo(x, y, ...) with arguments x, y, etc.\nAs shown, Opshin functions support recursion, i.e. the function fibonacci is visible inside itself and can be called from within itself.When there are several arguments, you can use the name of the argument to specify the argument during calling.\nThis allows for cleaner code and makes code robust to changes to the function signature.\ndef foo(x: int, y:int, z:int) -> int:\n    return (x + y) * z\n# you can specify the name of the argument to make clear which number is which argument\nassert foo(x=1, y=2, z=3) == foo(1, 2, 3)\n# you can also change the order and provide keywords only partially\nassert foo(z=3, x=1, y=2) == foo(1, 2, z=3)\nIf the function does not have a return statement in some path, the implicit return value is None.\nThis can be useful for code that has side-effects, such as assertion checks.\ndef check_valid(n: int) -> None:\n  assert n > 0, f\"Invalid negative int encountered: {n}\"\nIf the type annotation is missing for any field, the implicit annotation is Any.\nThis may be fine for your use case, but note that this is slightly less efficient (and less clear to the reader) than a properly type annotated function.Note that you can define functions locally and within other functions, so that they do not clutter your namespace and can not be used in the wrong context.\nThe following is legal.\ndef mul_twice(x: int) -> int:\n   def mul_once(x: int) -> int:\n        return x * x\n   return mul_once(x) * mul_once(x)\nprint(mul_twice(5))\n# \"625\"","lambdas-and-list-expressions#Lambdas and list expressions":"Generally OpShin does not support the use of lambda functions, as they don't allow specifying types in the function signature.\nInstead, consider using a local function definitions or list expressions. For example instead of the following expression\nys = map(lambda x: 2*x, filter(lambda x: x > 0, xs)) # does not work.\nYou could either define local functions like this\ndef greater_zero(x: int) -> bool:\n  return x > 0\ndef mul_2(x: int) -> int:\n  return 2*x\nys = map(mul_2, filter(greater_zero, xs)) # does not work.\nOr you can express this very compactly and readable directly in a list expression like this\nys = [2*x for x in xs if x > 0] # works!"}},"/user-manual/language_tour":{"title":"Language Tour","data":{"":"This section covers the syntax of Opshin and in particular the available Python language features.","opshin-is-python#OpShin is Python":"As a general disclaimer we would like to point\nout that OpShin is a restricted version of Python.\nWe encourage you to always try to write code the way\nyou would do it in a normal Python program.\nPlay around to see what is accepted by the compiler and what not.\nIf the compiler accepts your code, the code\nis safe to run (the only notable exception are type downcasts, covered later).The main goal of OpShin is that you can express\nthe smart contract logic the way you want -\nhence the choice of Python, which is designed to be\nsimple and intuitive.If you find yourself going to great lengths to satisfy\nthe OpShin compiler, please do open an Issue\nat the GitHub repository.\nWe are always looking for feedback to simplify\nthe experience of coding with OpShin."}},"/user-manual/language_tour/loop_statements":{"title":"Loop Statements","data":{"":"Opsin supports both while and for loops.","while-loops#while loops":"while loops in Opshin work just like in Python.\nThey have a body and a boolean expression and the code in the body is looped while the boolean expression returns True.\ncount = 0\nwhile count < 5:\n    print(\"'count' is \", count, \".\")\n    count += 1","for-loops#for loops":"for loops are use for iterating over lists and other iterables.\nThe loop through the elements of the iterable and executes the code in the block using the element from the list.\nnames = [\"Ada\", \"Voltaire\", \"Basho\"]\nfor name in names:\n    print(name)\nfor i in range(10):\n    ...\nDictionaries are also iterables and they can be iterated over using a for loop:\nscores = {\"Byron\": 1200, \"Vasil\": 900, \"Ada\": 1790, \"Shelley\": 1400}\n# Iterating over the keys and values using '.items()'\nfor name, score in scores.items():\n    print(name + \" scored: \" + str(score))\n# Iterating over the keys using '.keys()'\nfor name in scores.keys():\n    ...\n# Iterating over the values using '.values()'\nfor score in scores.values():\n    ..."}},"/user-manual/language_tour/primitive_types":{"title":"Primitive Types","data":{"":"Opshin has 5 primitive types.\nThese are called primitive as they are the basis of all other types\nand not composed of others.\nint\nbool\nbytes\nstr\nNone","int#int":"This is the only numeric type in Opshin.\nIt represents integer numbers.\nOpshin's int type works just like the int type in Python and can be written in different notations.\nNote that all of the below examples evaluate to an integer and can be compared and added to each other!\n# Opshin supports typical integer literals:\nmy_decimal = 17  # decimal notation\nmy_binary  = 0b10001  # binary notation\nmy_hex     = 0x11  # hexadecimal notation\nmy_octal   = 0o121 # octal notation\n# What will this print?\nprint(my_decimal == my_hex)","operation-on-integers#Operation on integers":"OpShin offers a number of builtin operations for integers.\n# Addition\na = 5 + 2  # returns 7\n# Subtraction\na = 5 - 2  # returns 3\n# Multiplication\na = 5 * 2  # returns 10\n# Integer division (floored)\na = 5 // 2  # returns 2\n# Power\na = 5 ** 2  # returns 25\nProper Division is not supported because UPLC has not way to represent floating point numbers.\nIf you want to perform operations on rational numbers, use the fractions library","bool#bool":"The bool type has two possible values: True or False.\nControl flow (if/else, while) are usually controlled using boolean types.\nbooly = False","operation-on-booleans#Operation on Booleans":"OpShin offers a number of builtin operations for booleans.\n# Conjunction\nb = True and False  # returns False\n# Disjunction\nb = True or False  # returns True\n# Negation\nb = not True  # returns False\n# Cast to integer\nb = int(True)  # returns 1 (False gives 0)","str#str":"The str type in Opshin stores Strings, i.e. human-readable text.\nIt is mostly used for printing debug messages.\nstringy = \"hello world\"\nnot_so_secret_message = \"...\"","operation-on-strings#Operation on Strings":"OpShin offers some builtin operations for strings.\n# Concatentation\ns = \"hello \" + \"world!\"  # Returns \"hello world!\"\n# Cast to integer\ns = int(\"42\")  # returns 42","encode#.encode()":"str are usually stored in binary format in the so-called UTF-8 encoding.\nThis is for example the case for native token names.\nThe function encode transforms a normal, readable string into its binary representation.\n\"OpShin\".encode()  # returns b\"\\x4f\\x70\\x53\\x68\\x69\\x6e\"","str-1#str()":"If you want to convert anything into a string for debugging purposes, you may call the function str on it.\nstr(42)  # returns \"42\"\nNote that print also implicitly calls str on its input before printing it for your convenience.\nprint(42)  # prints \"42\"","format-strings#Format strings":"More conveniently, if you want to combine strings and other values to a nicely formatted output,\nuse formatting strings like this:\nprint(f\"the value of a is {a}, but the value of b is {b}\")\nThis will print the original string and substitute everything between { and }\nwith the evaluated expression.","bytes#bytes":"The bytes type in Opshin represents an array/string of bytes, i.e. it is a list of integers in the range 0-255.\nIt's usually called ByteArray or ByteString in other programming languages.\nYou may use it to store raw binary data.\nmy_bytes = b\"ooh a bytestring\"\nThis type is usually used to represent hashes or CBOR.\nNote that bytestrings per default generate the bytestring for the ASCII character input.\nIf you have a bytestring 0xaf2e221a represented in hexadecimal format, you can write it like this as a literal in OpShin.\nhashy = b\"\\xaf\\x2e\\x22\\x1a\"\nYou may also use the helper function fromhex usually invoked in Python as bytes.fromhex. In OpShin you need to call it on a specific bytes instance, like b\"\" (an empty bytestring).\nhashy = b\"\".fromhex(\"af2e221a\")","operation-on-bytes-bytestrings#Operation on bytes (ByteStrings)":"OpShin offers operations for bytestrings.\n# Concatentation\ns = b\"hello \" + b\"world!\"  # Returns b\"hello world!\"","---indexing-and-slicing#[] - indexing and slicing":"Python has a general concept of accessing elemtns at a specific index or accessing a slice of them.\nThis also works for bytes. You can either access a single byte of the string.\nb\"test\"[1]  # returns 101\nOr you can access a substring of the bytes from the first (inclusive) to last (exclusive) indicated\nindex using [a:b] slicing syntax.\nb\"test\"[1:3]  # returns b\"es\"\nIn python, negative indices y indicate access at len(x) - y for object x.\nThe following returns the byte at the last position of the byte string!\nb\"test\"[-1]  # returns 116\nThis also works with slices.","decode#.decode()":"bytes may represent unicode UTF-8 encoded strings.\nThis is for example the case for native token names.\nThe function decode transforms a byte string into a normal, readable string.\nb\"\\x4f\\x70\\x53\\x68\\x69\\x6e\".decode()  # returns \"OpShin\"","hex#.hex()":"bytes are better readable when displayed in hexadecimal notation.\nUse hex for this.\nb\"\\x4f\\x70\\x53\\x68\\x69\\x6e\".hex()  # returns \"4f705368696e\"","len#len()":"If you want to know the length of a bytestring, call len() on it.\nlen(b\"OpShin\")  # returns 6","none#None":"The None type is exactly like the None type in Python.\nIn other cardano smart contract languages it's called unit and denoted by empty brackets, ().\nIt doesn't do anything and is usually used to denote the absence of a value.\nnull_val = None"}},"/user-manual/language_tour/structure":{"title":"Structure","data":{"":"OpShin code is an imperative programming language.\nAs such, code is written by instructing the computer to perform\ncomputations.\nEach line of code corresponds to one instruction.\nA simple instruction is the assignment.\n# Assign value 2 to variable named a\na = 2\nIf we want to not only store but also read the value,\nwe can print it like this.\n# Assign value 2 to variable named a\na = 2\n# print the content of variable a\nprint(a)\nWhen executed locally, this will print 2 to the command line.\nWhen executed on chain, this code will append the string \"2\" to the\non-chain debug logs - you can use this to inspect how your code is working!Can you guess what the following program will print?\na = 2\nb = 4\nprint(a + b)","types#Types":"Every variable in OpShin has a type.\nIn general we do not need to tell OpShin in advance what type\nvariables has - it is able to derive the type on its own.\nIn the above example, variable a has type int.\nThis is the type for whole (integer) numbers.\nThere are a few more types that are introduced in the following sections.Note that types are important in OpShin.\nIf types do not match at compilation time, the contract can not be compiled.\nThis is to avoid unnecessary errors and prevent bugs in the code.\nFor example the following is not allowed, since it is a non-sensical instruction:\na = 2 + \"hello\"\nThe left part of this addition has type int while the right part has type str (the text/\"String\" type).\nAn addition between them is not unambiguous and generally does not make too much sense.\nHence, when trying to compile this statement, you will face a compiler error.You may see these errors a lot (but hopefully not too often).\nThey are telling you in advance that an operation will not work as expected.\nDon't fret! Take these error messages as guidance on what works and what not and adjust\nyour program as required by the compiler to obtain valid code.\nIt is not possible to change the type of your variable later.\nThe following program is forbidden\na = 10\na = \"hello\"\nInstead, we recommend simply changing the variable name if you want to change the type.\nThis will also be less confusing to the reader!","control-flow#Control flow":"In OpShin, control flow can be introduced using statements like if.\nif a == 2:\n    print(\"a is equal to 2!\")\n    a = 10\nprint(\"hello!\")\nIn this case, the expression a == 2 has a boolean type.\nIt can evaluate to either True (a is indeed equal to 2) or False.\nIf it is True, then the indented part is executed, so the program will print a is equal to 2!\nand afterwards assign the value 10 to a.The unindented part will always be executed. Generally, indentation indicates that code\nbelongs to a different \"layer\" of the program, i.e. an if/else statement, a loop, a function or a class."}},"/user-manual/smart_contract_tour/advanced":{"title":"Advanced Topics","data":{"":"This section contains a few selected, advanced use cases of OpShin.","compiler-flags#Compiler Flags":"OpShin provides several flags that enable, control or disable optimizations.\nConcretely the following flags are available (visible when calling opshin --help):\nFlag\tDescription\t-fcompress-patterns\tEnables the compression of re-occurring code patterns. Can reduce memory and CPU steps but increases the size of the compiled contract.\t-fiterative-unfold-patterns\tEnables iterative unfolding of patterns. Improves application of pattern optimization but is very slow.\t-fconstant-index-access-list\tReplace index accesses with constant parameters with optimized constant accesses. Reduces memory and CPU steps but increases the size of the compiled contract.\t-fconstant-folding, --cf\tEnables experimental constant folding, including propagation and code execution. See below for a detailed explanation.\t-fremove-dead-code\tRemoves dead code and variables from the contract.\t-ffast-access-skip FAST_ACCESS_SKIP\tHow many steps to skip for fast list index access, default None means no steps are skipped (useful if long lists are common).\t-fdeduplicate\tRemoves duplicated parts of the AST from the lowest level program representation, the UPLC level. This can slightly increase execution cost at a significant reduction of size\t-fremove-traces\tRemoves all error messages, print statements and other traces from the program. As OpShin usually prints extensive debug information, this significantly reduces contract size, but makes debugging much harder.","optimization-levels#Optimization Levels":"OpShin, similar to C-compilers, features optimization levels. These control which optimizations are applied to the generated code to make it smaller and more performant, but at the same time more difficult to debug.\nThe levels reach from 0 to 3, where higher numbers indicate more optimizations.\nHowever, as opposed to C-programs, there are not yet many debugging tools that require non-optimized ode.\nThus, as a typical user, optimizing less than level 2 will not bring any debugging benefits.\nTherefore, OpShin per default optimizes at level 2.\nLevel 3 enables some slow optimizations and in theory allows optimizations that change the semantics, i.e., the behavior, of the contract.\nIn practice, this will never have more of an effect than removing print statements or assertion messages.\nHowever, these messages are quite useful in practice and thus level 3 should not be enabled unless the contract has been thoroughly tested.The following optimizations are enabled by each optimization level (where each optimization level contains all optimizations of the lower optimizations):\nO0: None\nO1:\n-fcompress-patterns\n-fconstant-index-access-list\n-fremove-dead-code\nO2:\n-fconstant-folding\n-ffast-access-skip 5\nO3:\n-fiterative-unfold-patterns\n-fdeduplicate\n-fremove-traces\nFlags can be overridden by passing them specifically after specifying an optimization level, e.g., opshin build ... -O2 -ffast-access-skip 2.","constant-folding#Constant Folding":"OpShin supports the command-line flag --constant-folding or short --cf.\nWith this flag, every expression is evaluated at compile time\nby the python eval command.\nOn one hand this enables the precomputation of expensive constants in your code.\nSpecifically it evaluates all expressions that invoke only constants or variables that are\ndeclared exactly once in the contract.\nprint statements are not pre-evaluated.\nFor example, the following expressions would be folded at compile time:\n0 == 1  # evaluates to False\n@dataclass\nclass A(PlutusData):\n    a: int\n    b: bytes\nA(0, b\"\") # evaluates to the object\ndef foo(x):\n    return x\nfoo(0) # evaluates to 0\nbar = 2\nbar = 1\nbar + 1  # is not evaluated at compile time","multi-purpose-contracts#Multi-Purpose Contracts":"Multi-Purpose contracts are special contracts that can act for different purposes, for example as Spending verification and as Minting verification contract. The benefit is that the contract's hash stays the same for the different purposes, allowing to derive the minting policy and the contract spending address across purposes. An example of such a contract is the \"Wrapped Token\" contract, which allows minting a specific token if funds are deposited at its spending address.By default in PlutusV3, all contracts can act as multi-purpose contracts.When building a transaction that executes your smart contract,\nyou need to explicitly add your contract for each minting, spending etc invocation in your final transaction. The contract will be called several times during the transaction, with different parameters in Datum, Redeemer and Purpose, depending on your configuration.","checking-the-integrity-of-objects#Checking the integrity of objects":"OpShin never checks that an object adheres to the structure that is declared for its parameters.\nThe simple reason is that this is costly and usually not necessary.\nMost of the time an equality comparison (==) between PlutusData objects\nis sufficient (and fast).There are cases where you want to ensure the integrity of a datum however.\nFor example in an AMM setting where the pool datum will be re-used and potentially re-written\nin subsequent calls.\nIn order to prevent malicious actors from making the datum too big to fit in subsequent transactions\nor to prevent them from writing values of invalid types into the object, you may use check_integrity.An example use case is found below.\nThis contract will fail if anything but a PlutusData object with constructor id 2\nand two fields, first integer and second bytes, is passed as a datum into the contract.\nNote: Yes, this implies that without the explicit check the contract may pass with whatever\ntype datum actually is, since its fields or constructor id are never explicitly accessed.\nfrom opshin.prelude import *\nfrom opshin.std.integrity import check_integrity\n@dataclass\nclass SomeDatum(PlutusData)\n    CONSTR_ID = 2\n    a: int\n    b: bytes\ndef validator(context: ScriptContext):\n    datum: SomeDatum = own_datum_unsafe(context)\n    check_integrity(datum)"}},"/user-manual/smart_contract_tour/common_design_patterns":{"title":"Common Design Patterns","data":{"":"There are number of design patterns that have been refined and enabled as Plutus has advanced from V1 to V2,\nand now to V3. This document seeks to be a non-exhaustive reference to these design patterns and practices.","enforcing-uniqueness#Enforcing Uniqueness":"Enforcing the uniqueness of policies, asset names, or new outputs is useful in a number of contexts.","one-shot-minting-policies#\"One-Shot\" Minting Policies":"A validator is parameterized with an OutputReference, the minting validator\nenforces that the inputs to the transaction contain the corresponding UTxO as\ninput. By doing this, the minting policy is ensured to only validate once and\nonly once (since an unspent transaction output can only be spent once, by\ndefinition). In some designs, this logic is used for only a subset of redeemers\nto allow more flexible minting policies.Let's walk through an example.An NFT (Non-Fungible Token) can be created using a one-shot minting policy that\nensures each minted value is validated by spending a specific UTxO provided\nthrough the transaction inputs. This minting policy uses a validator parameter\nof OutputReference to confirm that the transaction spends the UTxO.\nAdditionally, the policy guarantees that only one token is minted, ensuring the\nNFT's uniqueness.First define OutputReference as parameter and set the action type to mint or\nburn the token based on the value provided in the redeemer.\nfrom dataclasses import dataclass\nfrom typing import Union\nfrom opshin.prelude import *\n@dataclass()\nclass MintingAction(PlutusData):\n    CONSTR_ID = 0\n@dataclass()\nclass BurningAction(PlutusData):\n    CONSTR_ID = 1\nAction = Union[MintingAction, BurningAction]\ndef validator(utxo_ref: TxOutRef, context: ScriptContext) -> None:\n    assert isinstance(context.purpose, Minting), \"Minting policy expected\"\n    redeemer: Action = context.redeemer\n    # Minting and burning rules will follow after this\n    ...\nThe validator must handle minting/burning operations and ensures that only one value is minted; it will fail otherwise.\nfrom dataclasses import dataclass\nfrom typing import Dict, Union\nfrom opshin.prelude import *\n@dataclass()\nclass MintingAction(PlutusData):\n    CONSTR_ID = 0\n@dataclass()\nclass BurningAction(PlutusData):\n    CONSTR_ID = 1\nAction = Union[MintingAction, BurningAction]\ndef validator(utxo_ref: TxOutRef, context: ScriptContext) -> None:\n    purpose = context.purpose\n    assert isinstance(purpose, Minting), \"Minting policy expected\"\n    redeemer: Action = context.redeemer\n    # Minting and burning rules follow after this\n    minted_for_policy: Dict[TokenName, int] = context.transaction.mint.get(\n        purpose.policy_id, {}\n    )\n    minted_assets = list(minted_for_policy.items())\n    assert len(minted_assets) == 1, \"Mint exactly one asset for this policy\"\n    _token_name, quantity = minted_assets[0]\n    # Checking the UTxO consumption happens in the next step.\nTo enforce uniqueness, we need to ensure that the UTxO defined as OutputReference in the validator parameters is\nconsumed. This is because every OutputReference is a unique combination of the Transaction ID and an Output Index\nInteger. It's important to remember that the Transaction ID is a Hash<Blake2b_256, Transaction>, which is also a\nunique identifier and will not be repeated.\nfrom dataclasses import dataclass\nfrom typing import Dict, Union\nfrom opshin.prelude import *\n@dataclass()\nclass MintingAction(PlutusData):\n    CONSTR_ID = 0\n@dataclass()\nclass BurningAction(PlutusData):\n    CONSTR_ID = 1\nAction = Union[MintingAction, BurningAction]\ndef validator(utxo_ref: TxOutRef, context: ScriptContext) -> None:\n    purpose = context.purpose\n    assert isinstance(purpose, Minting), \"Minting policy expected\"\n    redeemer: Action = context.redeemer\n    # Minting and burning rules follow after this\n    minted_for_policy: Dict[TokenName, int] = context.transaction.mint.get(\n        purpose.policy_id, {b\"\":0}\n    )\n    minted_assets = minted_for_policy.items()\n    assert len(minted_assets) == 1, \"Mint exactly one asset for this policy\"\n    token_name, quantity = minted_assets[0]\n    consumed_refs = [tx_in.out_ref for tx_in in context.transaction.inputs]\n    if isinstance(redeemer, MintingAction):\n        assert utxo_ref in consumed_refs, \"Required UTxO was not consumed\"\n        assert quantity == 1, \"Mint a single token\"\n    else:\n        assert quantity == -1, \"Burn a single token\"","receipts#Receipts":"A validator can mint a unique receipt for a transaction by requiring that the name of the asset is any\nunique value specific to the transaction where validation is set to occur. In other words, if we enforce\nthat only one receipt is to be minted per transaction, we can use blake2b_256 and cbor.serialise to\nget a unique value that can be assigned to the AssetName expected for the receipt from the\nOutputReference from the first Input in our transactions inputs.\nfrom hashlib import blake2b\nfrom typing import Dict\nfrom opshin.prelude import *\ndef validator(context: ScriptContext) -> None:\n    purpose = context.purpose\n    assert isinstance(purpose, Minting), \"Minting policy expected\"\n    tx_info = context.transaction\n    first_input = tx_info.inputs[0]\n    minted_for_policy: Dict[TokenName, int] = tx_info.mint.get(purpose.policy_id, {b\"\":0})\n    minted_assets = minted_for_policy.items()\n    assert len(minted_assets) == 1, \"Mint exactly one receipt token\"\n    asset_name, quantity = minted_assets[0]\n    expected_name = blake2b(\n        first_input.out_ref.to_cbor()\n    ).digest()\n    assert asset_name == expected_name, \"Derived token name mismatch\"\n    assert quantity == 1, \"Receipt must mint a single token\"\nWe could use this validator to mint a unique receipt for a transaction. It will get the first UTxO reference\nand will compare it with the asset name.","unique-outputs#Unique Outputs":"","problem-double-satisfaction#Problem: Double Satisfaction":"To prevent a vulnerability called 'Double Satisfaction' (see more below), one\nmust ensure that outputs associated with a given input are only counted once\nacross all possible validations occuring in a transaction.In the eUTxO model, a common anti-pattern is to predicate spending upon logic\nthat is specific to a given input - without ensuring the uniqueness of the\ncorresponding output.Let's walk through a short example: Bob wants to sell 20 SCOIN and wants at\nleast 5 ADA in return; the contract would require that at least 5 ADA is paid\nto Bob.Step-by-step swap:\nBob sends 20 SCOIN to the validator with a datum containing his\nVerificationKeyHash and the price (5 ADA) required to get the 20 SCOIN.\nAlice makes a new transaction getting the 20 SCOIN and paying 5 ADA to Bob.\nAlice will get 20 SCOIN.\nBob will get 5 ADA.\nfrom dataclasses import dataclass\nfrom typing import Dict, List\nfrom opshin.prelude import *\ndef lovelace_of(value: Dict[PolicyId, Dict[TokenName, int]]) -> int:\n    return value.get(b\"\", {b\"\": 0}).get(b\"\", 0)\n@dataclass()\nclass DatumSwap(PlutusData):\n    beneficiary: PubKeyHash\n    price: int\n# ! DANGER: exploitable\ndef validator(context: ScriptContext) -> None:\n    purpose = context.purpose\n    assert isinstance(purpose, Spending), \"Spending purpose expected\"\n    datum: DatumSwap = own_datum_unsafe(context)\n    beneficiary_address = Address(\n        PubKeyCredential(datum.beneficiary), NoStakingCredential()\n    )\n    payments: List[TxOut] = [\n        tx_out\n        for tx_out in context.transaction.outputs\n        if tx_out.address == beneficiary_address\n    ]\n    total_paid = sum([lovelace_of(tx_out.value) for tx_out in payments])\n    assert total_paid >= datum.price, \"Insufficient payment\"\nSo far, everything is ok, but what if we have some UTxOs locked in the\nvalidator at similar prices?Bob wants to sell 20 XCOIN, and 20 SCOIN and wants at least 10 ADA in return\nfor each UTxO; the contract would require that at least 10 ADA be paid to Bob.\nNow Alice comes and pays Bob 10 ADA, in the same transaction she takes both the\n20 SCOIN and 20 XCOIN because the contract only ensures that at least 10 ADA is\npaid to Bob.So, this validator could potentially cause be satisfied twice with the same\ninputs, where anyone can pay once and get every UTxO unlocked at the same price\nor less.","solution-tagged-outputs#Solution: Tagged Outputs":"What can we do? We have to ensure that each input has a corresponding unique\noutput to pay or predicate the logic of spending any input of the script on all\nof the inputs and outputs relevant to the business logic of the dApp.In addition, we have to remember that the code in the validator will be\nexecuted for every UTxO locked by the validator that we are trying to spend\nfrom. So we have to make sure that outputs aren't counted multiple times across\nmultiple executions of the validator (for each input validation).This can be achieved by tagging outputs with a value which is unique to the\ninput. Enough information is present in the OutputReference of the input to\ncreate a unique tag that must then be found in outputs.\nfrom typing import List\nfrom opshin.prelude import *\ndef lovelace_of(value: Dict[PolicyId, Dict[TokenName, int]]) -> int:\n    return value.get(b\"\", {b\"\": 0}).get(b\"\", 0)\n@dataclass()\nclass DatumSwap(PlutusData):\n    beneficiary: PubKeyHash\n    price: int\ndef validator(context: ScriptContext) -> None:\n    purpose = context.purpose\n    assert isinstance(purpose, Spending), \"Spending purpose expected\"\n    datum: DatumSwap = own_datum_unsafe(context)\n    beneficiary_address = Address(\n        PubKeyCredential(datum.beneficiary), NoStakingCredential()\n    )\n    tagged_outputs: List[TxOut] = []\n    for tx_out in context.transaction.outputs:\n        if tx_out.address == beneficiary_address:\n            output_datum = tx_out.datum\n            if isinstance(output_datum, SomeOutputDatum):\n                datum_value = output_datum.datum\n                # Soft-cast: ignore unrelated outputs instead of aborting the transaction.\n                if datum_value == purpose.tx_out_ref:\n                    tagged_outputs = [tx_out] + tagged_outputs\n    total_paid = sum([lovelace_of(tx_out.value) for tx_out in tagged_outputs])\n    assert total_paid >= datum.price, \"Tagged payment too small\"","state-thread-tokens-aka-stt#State Thread Tokens (a.k.a STT)":"It is often useful to have a mutable state which either changes with each transaction, or on a periodic\nbasis. One way to ensure that a datum is not 'spoofed' is to ensure that the input or reference input with\nthat datum contains an NFT which has been generated to be unique using one of the method described above.In this example, we will create an STT that tracks the sum of every transaction\nthat uses the STT. And for this, we will create a multivalidator with two\nresponsabilities: a minting and spending policy.The STT Minting Policy allows us to create new tokens with a counter datum initialized at 0.\nfrom typing import Dict\nfrom opshin.prelude import *\nEMPTY_VALUE: Dict[bytes, int] = {}\ndef validator(utxo_ref: TxOutRef, operator: PubKeyHash, context: ScriptContext) -> None:\n    purpose = context.purpose\n    tx_info = context.transaction\n    if isinstance(purpose, Minting):\n        minted_for_policy: Dict[TokenName, int] = tx_info.mint.get(purpose.policy_id, EMPTY_VALUE)\n        minted_assets = minted_for_policy.items()\n        assert len(minted_assets) == 1, \"Mint exactly one STT token\"\n        token_name, quantity = minted_assets[0]\n        assert quantity == 1, \"Mint a single STT\"\n        consumed_refs = [tx_in.out_ref for tx_in in tx_info.inputs]\n        assert utxo_ref in consumed_refs, \"Authorising reference missing\"\n        stt_outputs = [\n            tx_out\n            for tx_out in tx_info.outputs\n            if tx_out.value.get(purpose.policy_id, EMPTY_VALUE).get(token_name, 0) == 1\n        ]\n        assert len(stt_outputs) == 1, \"STT must be forwarded exactly once\"\n        datum: int = resolve_datum_unsafe(stt_outputs[0], tx_info)\n        assert datum == 0, \"Initial counter must be zero\"\n    elif isinstance(purpose, Spending):\n        # The spending branch is implemented below.\n        pass\n    else:\n        assert False, \"Unsupported script purpose\"\nfrom typing import Dict, Optional\nfrom opshin.prelude import *\ndef validator(utxo_ref: TxOutRef, operator: PubKeyHash, context: ScriptContext) -> None:\n    purpose = context.purpose\n    tx_info = context.transaction\n    if isinstance(purpose, Minting):\n        minted_for_policy: Dict[TokenName, int] = tx_info.mint.get(purpose.policy_id, {})\n        minted_assets = list(minted_for_policy.items())\n        assert len(minted_assets) == 1, \"Mint exactly one STT token\"\n        token_name, quantity = minted_assets[0]\n        assert quantity == 1, \"Mint a single STT\"\n        consumed_refs = [tx_in.out_ref for tx_in in tx_info.inputs]\n        assert utxo_ref in consumed_refs, \"Authorising reference missing\"\n        stt_outputs = [\n            tx_out\n            for tx_out in tx_info.outputs\n            if tx_out.value.get(purpose.policy_id, {}).get(token_name, 0) == 1\n        ]\n        assert len(stt_outputs) == 1, \"STT must be forwarded exactly once\"\n        datum = resolve_datum_unsafe(stt_outputs[0], tx_info)\n        assert isinstance(datum, int), \"Counter datum must be an integer\"\n        assert datum == 0, \"Initial counter must be zero\"\n        return\n    assert isinstance(purpose, Spending), \"Supported purposes are minting and spending only\"\n    own_utxo = own_spent_utxo(tx_info.inputs, purpose)\n    own_policy = own_policy_id(own_utxo)\n    assert operator in tx_info.signatories, \"Operator signature missing\"\n    stt_input: Optional[TxInInfo] = None\n    for tx_in in tx_info.inputs:\n        quantity = sum(tx_in.resolved.value.get(own_policy, {}).values())\n        if quantity > 0:\n            stt_input = tx_in\n            break\n    assert stt_input is not None, \"STT input not found\"\n    input_datum: int = resolve_datum_unsafe(stt_input.resolved, tx_info)\n    stt_output: Optional[TxOut] = None\n    for tx_out in tx_info.outputs:\n        quantity = sum(tx_out.value.get(own_policy, {}).values())\n        if quantity > 0:\n            stt_output = tx_out\n            break\n    assert stt_output is not None, \"STT must be forwarded\"\n    assert stt_input.resolved.address == stt_output.address, \"STT address mismatch\"\n    output_datum: int = resolve_datum_unsafe(stt_output, tx_info)\n    assert output_datum == input_datum + 1, \"Counter must increment by one\"\nHere is the part of the validator that ensures every transaction increments the value of the counter:\nWe check if the transaction is signed by the operator.\nWe recover the minting policy identifier from the spending input so we can locate the STT.\nWe check if an input NFT exists and has a datum with an integer.\nWe check if an output exists and has a datum with an integer.\nWe check if the output datum equals the input datum + 1.\nWhen compiling the script you can pass the operator public key hash as a parameter (for example via --force-three-params in the Opshin CLI). This keeps the key configurable without hard-coding it in the contract.","forwarding-validation--other-withdrawal-tricks#Forwarding Validation & Other Withdrawal Tricks":"By enforcing withdrawals from a specific given script, we can effectively\n'forward' the validation to this script being evaluated with the withdraw\nscript purpose. This is possible in particular because it is always possible to\nwithdraw an amount of 0 lovelace.We can leverage this to allow a script to be owner of one or multiple UTxOs\nthemselves locked by a much simpler script. In stead of normally ensuring that\nthe owner's PKH is present in the required signatories, we use a small script\nthat forward the validation to another single script also present in the\ntransaction.By using this trick in a spending validator, we can reduce the overhead that\ncomes from authorizing multiple spending. Indeed, instead of running the same\nbunch of logic multiple times (one for each input), we only run it once for the\nwithdrawal script. Since validators have access to the entire transaction as a\ncontext, regardless of their execution purpose, it is feasible most of the\ntime.This is being used by a number of dApps now in production in order to optimize\nevaluation budgets and reach a higher efficiency.","going-further#Going further":"","anastasia-labs-design-patterns#Anastasia Labs' design patterns":"https://github.com/Anastasia-Labs/design-patterns\nA library designed to abstract away some of the more unintuitive and\nlesser-known eUTxO design patterns, making them more accessible to developers.","plutonomicon#Plutonomicon":"https://github.com/Plutonomicon/plutonomicon\nA developer-driven guide to the Plutus smart contract platform in practice.\nThis page is adapted from the Aiken documentation, where you can find the same patterns written in aiken."}},"/user-manual/smart_contract_tour":{"title":"Smart Contract Tour","data":{"":"This section will teach you how to write Cardano smart contracts in Opshin."}},"/user-manual/smart_contract_tour/handling_time":{"title":"Handling Time","data":{"":"In a lot of contracts, time is of the essence.\nProperly handling time is essential for a lot of contracts like auctions and swaps.The valid_range property in the ScriptContext specifies within what time the transaction can be submitted, it's used to constrain the time of the transaction.\nIt's of type POSIXTimeRange.","posixtimerange#POSIXTimeRange":"The POSIXTimeRange type is used to specify a time range.\ndataclass()\nclass POSIXTimeRange(PlutusData):\n    \"\"\"\n    Time range in which this transaction can be executed\n    \"\"\"\n    # Lower bound for the execution of the transaction\n    # Can be negative infinity or a int.\n    lower_bound: LowerBoundPOSIXTime\n    # Upper bound for the execution of the transaction\n    # Can be positive infinity or a int.\n    upper_bound: UpperBoundPOSIXTime\nA POSIXTimeRange can be visualized like a subsection of a numberline starting from negative infinity(-∞) to positive infinity (+∞)\n         ⬤-------------→⬤\n-∞       -3 -2  -1   0   1   2   3       +∞\n └┴┴┴┴┴─┴─┴──┴───┴───┴───┴───┴───┴─┴─┴┴┴┴┘","useful-methods#Useful Methods":"Helper functions for the POSIXTimeRange type are stored in opshin.ledger.interval.","make_rangelower_bound-int-upper_bound-int---posixtimerange#make_range(lower_bound: int, upper_bound: int) -> POSIXTimeRange":"This takes a the lower bound as the first argument and the upper bound as the second argument makes a POSIXTimeRange that starts from lower_bound and ends at upper_bound.\nvalid_range = make_range(-3, 2)\nThis can be visualized as:\n     lower_bound        upper_bound\n          ⬤----------------→⬤\n-∞       -3 -2  -1   0   1   2   3       +∞\n └┴┴┴┴┴─┴─┴──┴───┴───┴───┴───┴───┴─┴─┴┴┴┴┘","make_fromlower_bound-int---posixtimerange#make_from(lower_bound: int) -> POSIXTimeRange":"This takes a the lower bound as the first argument and makes a POSIXTimeRange that starts from lower_bound and ends at positive infinity.\nvalid_range = make_from(-1)\nThis can be visualized as:\n            lower_bound     \n                 ⬤---------------------→⬤\n-∞       -3 -2  -1   0   1   2   3       +∞\n └┴┴┴┴┴─┴─┴──┴───┴───┴───┴───┴───┴─┴─┴┴┴┴┘","make_toupper_bound-int---posixtimerange#make_to(upper_bound: int) -> POSIXTimeRange":"This takes a the upper bound as the first argument and makes a POSIXTimeRange that starts from negative infinity and ends at upper_bound.\nvalid_range = make_to(1)\nThis can be visualized as:\n                    upper_bound \n ⬤---------------------→⬤\n-∞       -3 -2  -1   0   1   2   3       +∞\n └┴┴┴┴┴─┴─┴──┴───┴───┴───┴───┴───┴─┴─┴┴┴┴┘","vesting-contract#Vesting Contract":"To really grok how time is managed on Cardano we'll write a simple vesting contract."}},"/user-manual/smart_contract_tour/the_scriptcontext":{"title":"The ScriptContext","data":{"":"Majority of the logic of smart contracts has to do with making assertions about certain properties of the ScriptContext.\nIt contains a lot of useful information such as:\nWhen is the transaction?\nWhat will the inputs of the transactions be?\nWhat will the outputs of the transaction?\nAll of these things are contained in the ScriptContext object passed into the contract as the last argument.\nThis section covers the most interesting parts of the Script Context - if you want to learn more check out the full documentation at the module description","scriptcontext#ScriptContext":"The ScriptContext is defined as:\n@dataclass()\nclass ScriptContext(PlutusData):\n    \"\"\"\n    Auxiliary information about the transaction and reason for invocation of the called script.\n    \"\"\"\n    transaction: TxInfo\n    redeemer: Anything\n    purpose: ScriptPurpose\nThe redeemer is arbitrary information provided by the user during building the transaction. It can indicate how the user intends to use the contracts, e.g., for cancelling or executing a submitted order.The second most important field in the ScriptContext is the transaction field which is of type TxInfo.","txinfo#TxInfo":"@dataclass()\nclass TxInfo(PlutusData):\n    \"\"\"\n    A complex agglomeration of everything that could be of interest to the executed script, regarding the transaction\n    that invoked the script\n    \"\"\"\n    # The input UTXOs of the transaction.\n    inputs: List[TxInInfo]\n    # The reference UTXOs of the transaction.\n    reference_inputs: List[TxInInfo]\n    # The output UTXOs created by the transaction.\n    outputs: List[TxOut]\n    # Transaction fee to be payed for the transaction in Lovelace.\n    fee: int\n    # The value minted in the transaction.\n    mint: Value\n    certificates: List[Certificate]\n    # Withdrawals from specific stake keys\n    withdrawals: Dict[StakingCredential, int]\n    # The range of time in which this transaction is valid\n    validity_range: POSIXTimeRange\n    # The signatures for the transaction.\n    signatories: List[PubKeyHash]\n    # All redeemers passed to all script invocations\n    redeemers: Dict[ScriptPurpose, Redeemer]\n    # All datums present in any inputs\n    datums: Dict[DatumHash, Datum]\n    # The ID of the transaction.\n    id: TxId\n    # metadata for governance actions\n    votes: Dict[Voter, Dict[GovernanceActionId, Vote]]\n    proposal_procedures: List[ProposalProcedure]\n    current_treasury_amount: OptionalLovelace\n    treasury_donation: OptionalLovelace","txininfo#TxInInfo":"This type contains data about a UTXO being used as a transaction input.\n@dataclass()\nclass TxInInfo(PlutusData):\n    \"\"\"\n    The plutus representation of an transaction output, that is consumed by the transaction.\n    \"\"\"\n    out_ref: TxOutRef\n    resolved: TxOut","txout#TxOut":"This type contains data about a UTXO.\n@dataclass()\nclass TxOut(PlutusData):\n    \"\"\"\n    The plutus representation of an transaction output, consisting of\n    - address: address owning this output\n    - value: tokens associated with this output\n    - datum: datum associated with this output\n    - reference_script: reference script associated with this output\n    \"\"\"\n    address: Address\n    value: Value\n    datum: OutputDatum\n    reference_script: Union[NoScriptHash, SomeScriptHash]"}},"/user-manual/smart_contract_tour/validator_scripts":{"title":"Validator Scripts","data":{"":"Congrats, if you've gotten to this section you now understand the basics of Opshin.\nNow we get to put those together to write smart contracts.If you remember from the page on the EUTXO model.\nUTXOs are like bundles of money and a datum stored on the blockchain, they are locked by a validator script which is run when someone attempts to spend that UTXO.\nOf course, this is only the case for spending contracts i.e. Contract addresses that hold actual UTxOs.\nMinting Scripts and other types of validators do not have a datum as parameter.Smart contract development on Cardano centers around writing validators in a way that allows only transactions that follow the business logic of the application.\nEvery validator is a simple pure function that takes two to three arguments:\nDatum: This is data stored alongside the UTXO on the blockchain (in the case of Spending Validators i.e. Contract Addresses).\nRedeemer: This data included in the transaction that attempts to spend the UTXO.\nScript Context: This object stores information about the transaction attempting to spend the UTXO.\nNote:\nDatum and Redeemer are entirely controlled by the user and may not be trusted, but the Script Context may be trusted as it is assembled by the node.\nConsequently, the Datum and the Redeemer can be of any type\ndepending on the contract, but the Script Context is always of type ScriptContext.\nA validator either does not fail or fails (i.e. through the use of assert or an out-of-index array access).\nIf it does not fail then, independent of the returned value, the contract execution is counted as a success\nand the contract validates the transaction.\nNote: Other Smart Contract languages return a boolean value that determines the success of the transaction.\nIf you return False in OpShin, the contract will succeed in any case.","example-validator---gift-contract#Example Validator - Gift Contract":"In this simple example we'll write a gift contract that will allow a user create a gift UTXO that can be spent by:\nThe creator cancelling the gift and spending the UTXO. (1)\nThe recipient claiming the gift and spending the UTXO. (2)\n# gift.py\n# The Opshin prelude contains a lot useful types and functions \nfrom opshin.prelude import *\n# Custom Datum\n@dataclass()\nclass GiftDatum(PlutusData):\n    # The public key hash of the gift creator.\n    # Used for cancelling the gift and refunding the creator (1).\n    creator_pubkeyhash: bytes\n    # The public key hash of the gift recipient.\n    # Used by the recipient for collecting the gift (2).\n    recipient_pubkeyhash: bytes\ndef validator(context: ScriptContext) -> None:\n    datum: GiftDatum = own_datum_unsafe(context)\n    # Check that we are indeed spending a UTxO\n    assert isinstance(context.purpose, Spending), \"Wrong type of script invocation\"\n    # Confirm the creator signed the transaction in scenario (1).\n    creator_is_cancelling_gift = datum.creator_pubkeyhash in context.tx_info.signatories\n    # Confirm the recipient signed the transaction in scenario (2).\n    recipient_is_collecting_gift = datum.recipient_pubkeyhash in context.tx_info.signatories\n    assert creator_is_cancelling_gift or recipient_is_collecting_gift, \"Required signature missing\"\nTwo notes:\nto access the datum that was attached to the spent output, the easiest way is to use own_datum_unsafe which is provided to you in the prelude\nwe don't access the redeemer here, because we don't need it. It would be available as context.redeemer\nThis might be a bit to take in, especially the logic for checking the signatures.\nThe most important part is that you see the parameters and the return type resp. the assert statements actually controlling the validation.\nIn the next chapter we'll do a deep dive into the single most important object in Cardano smart contracts, the ScriptContext."}},"/user-manual/what_i_wish_i_knew":{"title":"What I wish I knew when exploring Cardano","data":{"":"This documentation is a collection of tips and secret knowledge that may be\nuseful in your Cardano journey. Some may never be useful to you or only useful\nin the distant future. Yet, we hope that if we can save someone a few hours of\ndebugging and hunting down rabbits in bottomless holes, we have accomplished\nour mission.","cbor--cddl#CBOR / CDDL":"Pretty much everything in Cardano that requires serialization is done using a a\nstructured binary format called CBOR.\nThink of it as JSON but for binary data. You don't have to be an expert in CBOR\nto work on Cardano, but being familiar with the notation can be useful\nespecially for troubleshooting low-level stuff.There are two specific areas worth knowing:\nCDDL, which is a specification meta-language for CBOR. It's used to describe\nhow some data is encoded into bytes. In particular, the Cardano ledger\nmaintains a CDDL specification of all the Cardano\nobjects\nthat have to be serialized on-chain. Transaction serialization, for example, is\nentirely specified in this document. This specification is generally the\nsource of truth for many other tools.\nCBOR diagnostic provides a more human-readable, JSON-like syntax that\nis handy for debugging. We explain CBOR diagnostic in more detail in the\nTroubleshooting section.\nA well-known tool for debugging CBOR is cbor.me; there are\nalso numerous command-line utilities in various languages.","byron-addresses#Byron Addresses":"Cardano has two kinds of addresses, which are called by different names\ndepending on who you ask. Prior to the introduction of the Shelley era,\naddresses looked vastly different than what they look like today.For example: .We call these addresses \"Bootstrap addresses\" or simply \"Byron addresses\";\nin contrast to other addresses that are either called \"addresses\" or\n\"Shelley addresses\" when there's a possible ambiguity. Byron addresses are\nconsidered deprecated today and are likely not something you want to use ever.\nBut, you might come across them, for some legacy systems still use them.\nOutputs locked by a Byron address or inputs corresponding to such outputs are\nforbidden in transactions that have Plutus scripts! This means that\non-chain validators should never encounter Byron addresses in a validation\ncontext. This used to be different in the early days of the Alonzo era but was\nlater changed to avoid hazardous situations.","validity-intervals#Validity Intervals":"You probably know already that Cardano smart-contract execution is fully\ndeterministic.This, however, raises an interesting question: How to deal with time?Asking for the current time usually breaks determinism because asking the\nsame question at different moments may lead to different answers and, thus,\ndifferent execution paths. So how to introduce time in scripts validating\ntransactions?Cardano decouples transaction validations in two phases, and we typically refer\nto them as \"phase-1 validations\" and \"phase-2 validations\". Phase-1 validations\nare structural checks on a transaction performed by the ledger. For example,\nthis is when the ledger verifies that inputs referenced in a transaction are\nvalid, that minimum amounts for fees and outputs are met, etc...Among the available features of a transaction are \"validity intervals\" that\ndefine a period after which and until the ledger can consider the transaction\nvalid. The validity interval is made of a lower bound (optional) and an upper\nbound (optional), and it is verified during phase-1 validations. That is if a\ntransaction is said to be valid only after the 5th January 2030, it can only be\nsubmitted and considered valid by the ledger after that date. Similarly, if the\nvalidity interval defines an upper bound, then the transaction will sit in\nmempools until then. It is pruned if it doesn't make it into a block by the\nspecified date.Thereby, one can introduce a notion of time in validators through the means of\nvalidity intervals. Since they are checked during phase-1, a validator can\nassume that the transaction it validates is within the specified validity\ninterval. Hence, should you ensure that an action happens only after a specific\ndate, you can record that date as a datum and check that the transaction's\nlower bound is greater than the specified date.The validity interval can be as narrow as one second, allowing scripts to run at\nvery thin precisions. However, a narrow interval means getting the\ntransaction in a block may be more difficult. As a reminder, there's one block\nevery 20 seconds on average minted on the Cardano blockchain. Blocks are\nusually propagated fast, but it can take a few minutes under moments of heavy\nload.","serialization-strategies#Serialization strategies":"There's no canonical serialization of objects on Cardano. While there is indeed\na CDDL specification for core objectssee\nbelow, as mentioned earlier, there are still multiple possible\ninterpretations possible of the specification. For example, a CDDL\nspecification is unable to express in what order should keys in a map be\nserialized, or whether optional fields with default values (e.g. an optional\nlist of elements) should be omitted entirely or specified with an empty default\nvalue.While there are attempts, such as\nCIP-0021 to\nagree on a canonical serialization; the current Cardano ledger does not provide\nany such guarantee. Consequently, the recommended strategy when dealing with\ndeserialized objects that need to be reserialized is to always preserve the\noriginal bytes and not attempt to reserialize anything. At the same time,\nparsers should not assume one way over another and be ready to deserialize any\npossible representation that is compliant with the CDDL specification.This means, amongst other things, that there are multiple possible\nserializations of a transaction, and it may lead to surprising situations when\ntrying to recalculate the hash of an object.","cddl-files#CDDL files":"Era\tCDDL Specification\tByron\tbyron.cddl\tShelley\tshelley.cddl\tAllegra\tallegra.cddl\tMary\tmary.cddl\tAlonzo\talonzo.cddl\tBabbage\tbabbage.cddl\tConway\tconway.cddl","hash-digests#Hash digests":"Cardano uses mostly only blake2b as a hashing algorithm throughout the\nchain. Saying \"mostly\" because we can find some examples of SHA-256 in some\nparts of the Byron era, but let's not dwell on that.Many things called id are hash digests of some serialized objects.\nFor example, a stake pool id is a hash digest of the pool\npublic cold key. A transaction id is a hash digest value of the serialized\ntransaction body. And so forth.Hashes are generally 32-byte long on Cardano (or 256 bits), except for\ncredentials (i.e. keys or scripts) which are 28-byte long (or 224 bits). This\nis why a policy id is only 28 bytes long: a policy id is the hash digest of\na tagged script, and scripts can be used as credentials (i.e. part of\nan address). The same goes for any hash digest of a verification key.","policy-id-and-language-tags#Policy Id and language tags":"A policy id is a hash digest of a tagged script. Tagged is the keyword here.\nShould you try to calculate the policy id by simply hashing a serialized\nscript, you may find yourself with a wrong hash without knowing why.Raw scripts aren't exact pre-image of their hash digest. Before hashing,\nscripts are prefixed with a certain discriminator byte depending on the\nlanguage. For instance, any native script is prefixed with a 0x00\n(0b0000_0000) byte before hashing.Here's a table summarizing all discriminators:\nLanguage\tDiscriminator Byte\tNative\t0x00\tPlutus V1\t0x01\tPlutus V2\t0x02\tPlutus V3\t0x03\t\nThe subsequent versions of Plutus may likely follow the pattern.","rewards--withdrawals#Rewards & Withdrawals":"Ouroboros, the consensus algorithm used by Cardano, defines an incentive\nmechanism for stakeholders to participate in the consensus through rewards. Of\ncourse, you probably know that by now. Rewards are paid every epoch to\ndelegators that delegate their stake (i.e. ADA tokens) to a stake pool of the\nnetwork producing blocks on their behalf. Those rewards are, however, not paid\ndirectly to stakeholders; this would cause the network at every epoch boundary\nto pay out all rewards.Instead, Cardano has introduced a restricted concept of account, similar to\nwhat exists on account-based ledgers. This account is, however, singular in\nmany ways:\nIt is defined by some stake credentials and owned by them;\nIt can only receive rewards from the protocol but not from a user-defined transaction;\nIt is automatically delegated;\nIt is possible to withdraw funds from the account by issuing a withdrawal\n(which takes the form of a specific field in a transaction). A withdrawal sets\nthe balance of an account to 0 and provides a virtual pot of the account value\nto the transaction carrying it as if it was an input of that same value. That\nvalue can then be dispatched in one or more UTxO, as typically done with\nany input.The stake credentials associated with the account protect withdrawals as well.\nWho owns the stake credentials owns the right to withdraw from the account.\nThis means that reward withdrawals can be commanded by a script (and\nthus an Aiken program).","native-scripts#Native Scripts":"Before full-blown Plutus scripts, Cardano had a minimalistic scripting language\nusually referred to as \"Native Script\" or \"Phase-1 scripts\". It still\nexists and provides simple, albeit useful, programmability features to Cardano.\nNative scripts come in the form of a little domain-specific language with 6\nconstructors: key, all-of, any-of, n-of-m, after and before.In particular, they are quite handy in defining multisig addresses owned by\nmultiple tenants. You can find more about native scripts in\nCIP-1854\nand in the Formal Ledger Specification, Figure 4: Multi-signature via Native\nScripts.","the-clean-trick-avoid-replaying-blocks#The 'clean' trick: avoid replaying blocks":"Sometimes, the Cardano node will perform a complete re-validation of the chain\nas an integrity check. It does so by scanning through its local files, and\nreplaying blocks onto each other. On Mainnet, this procedure can take\nmultiple hours and is caused, in principle, by mainly two things:\nA restart after a non-clean shutdown of the node (e.g. a SIGKILL, or power outage);\nA critical change in the ledger version.\nThe detection of the first scenario is sometimes a bit clunky, and the unlucky\nones amongst us have likely already experienced (sometimes several times) the\ninfamous:\nReplayed block: slot 3844799 out of 112665654. Progress: 3.41%\nReplayed block: slot 3844783 out of 112665654. Progress: 3.42%\n...\nIt turns out that there exists a way to skip re-validations of the first kind.\nIndeed, on start-up, the node will look for an empty file named clean at the\nroot of its database folder.\nnode.db/\n├── clean              <------------ this fellow\n├── immutable\n├── ledger\n├── lock\n├── protocolMagicId\n└── volatile\nWhen present, the node will not replay blocks, unless it detects a critical\nchange in the ledger (second scenario) which happens fairly rarely. So it\nsuffices to create such a file (e.g. touch node.db/clean to avoid replaying\nblocks unecessarily. This is a useful trick to use when developing with a local\nnode, but totally unsound in a production setting (especially for SPO).","transaction-latency-vs-finality#Transaction latency vs finality":"In a distributed system like Cardano, the notion of latency and finality\nare often misunderstood (or swapped). Yet, it is crucial to get them right\nespecially when it comes to transactions.Latency is the time it takes for a transaction to appear on the blockchain, in\na block. Finality is the time it takes for a transaction to become immutable\nand permanent. Why is that different? Because the system is distributed! And\nthat means the information is only eventually true. How long is enough\ndepends on the interested parties and the type of transaction.It is hard to give a definite answer because finality directly depends on the\nproportion of adversarial stake in the system. And unfortunately, adversaries\ndon't walk the street waving their hands about the fact they are, in fact,\nadversaries. If we call ε the proportion of adversaries ([0;0.5]), and consider g\ntheir grinding power we find that under Ouroboros Praos (current Cardano\nconsensus algorithm), the probability of settlement errors in terms of the\nnumber of blocks (x) is given by the following equation:\nNow, what are good values for ε and g is hard to say. Regarding the\ngrinding power, values in the range of 10^9..10^10 are quite conservative\nvalues. The entire Bitcoin network has a grinding power of about 10^12. So\nunless the entire Bitcoin network is attacking Cardano, g is likely smaller\nthan 10^12. For the adversary proportion, as a rule of thumb, it's good to\nlook at the total stake of the largest stake pools to get an idea of how much\npower can a single entity gather.\nA good recommendation for sensitive transactions is thus to wait around 100-150\nblocks (30-50 min) whereas a few blocks is usually sufficient for small\npayments. If you want to play with the equation, feel free to look at\nthis interactive calculator.","developer-portal#Developer Portal":"There exists plenty of resources available on Cardano. Though there are a bit\nhard to find sometimes. As a rule of thumb (and unfortunately): avoid\nhttp://docs.cardano.org as it is often inaccurate, plain wrong or missing\ncrucial elements.On the other hand, the Cardano Developer\nPortal is a good entry point to many of the\necosystem tooling and resources. The \"Builder Tools\" section is particularly\nfurnished. It is community-maintained, curated and under constant evolution.\nFeel free to contribute and ask questions there as well!\nThis page is copied from the Aiken documentation."}},"/":{"title":"Cardano Smart Contracts in Python","data":{"":"Help shape OpShin for Plutus v3. Take our short survey to share your needs.\nShare your feedback\nBuild without limits\nmonitor-shimmer\nPlayground\nDocumentation\n❯_ Set up locally\nA pythonic programming language\n100% valid Python 3\nStrong static typing with inference\nIntuitive coding, the way you are used to\nLoops, custom types, recursion, imports...\nFocused on accessability\nQuick and friendly feedback with helpful error diagnotics\nSupported by basically every IDE\nProduce highly efficient code\nInteracts with python off-chain toolchains natively\nLeverage the Python ecosystem!\nZero configuration, one single capable tool\nUnittests, property based tests, formal verification...\nSyntax Highlighting, linting, static analysis...\nDeeply integrated with PyCardano for transaction building\nGet started quickly\nFull example can be run quickly\nFollow along the OpShin Pioneer Program\nPlenty more community built examples and tutorials at awesome-opshin\nJoin the Discord\nWhat is OpShin?\nOpShin is a new programming language and toolchain for developing\nsmart contracts on the Cardano blockchain. It is focusing on accessability and\ndeveloper experience.\nOpShin is 100% valid Python 3. In this way it can seamlessly integrate\nwith off-chain tools built in Python such as PyCardano.\nIt can also leverage the existing testing frameworks and IDEs\nand allows developers to re-use knowledge or focus on attaining\nknowledge about a simple and general purpose language.\nWhy build another smart contract language?\nHaskell is hard and almost no developer is used to it.\nOn the other hand, Python is praised for its simplicity and\nused in almost 25% of all projects on the internet (compare that to roughly 0.65% for Haskell).\nSo the ecosystem for Python is huge and full of interesting tools\nthat leverage the developer experience.\nThe toolchain based on python can leverage these tools\nto provide a safe and enjoyable developer experience.\nIs Python the right language for smart contracts? It's not even type safe right?\nWe chose Python because it is simple and intuitive.\nThis is a great basis to improve security of contracts -\nif they are easy to read and understand, a larger group of people can interpret them.\nTo combat the problems that come with dynamically typed languages,\nOpShin enforces a strict type system on top of Python, similar to the Haskell type system.\nHence, you enjoy the simplicy of Python programming and the safety of properly typed code.\nI thought Cardano smart contracts had to be written in Haskell?\nThis is a common misconception. The current Cardano node implementation\ndoes indeed happen to be written in Haskell. The virtual machine for\nexecuting smart contracts that comes baked into the node is also\nimplemented in Haskell. But that does not mean that it is Haskell which\nis executed by the smart contract virtual machine.\nThe virtual machine is a language interpreter which executes a\nsmart contract language called 'Untyped Plutus Core' (abbrev.\nUPLC) often referred to simply as 'Plutus'.\nYet UPLC isn't something developers are expected to write by hand.\nInstead, it is a compilation target (like WebAssembly for the world wide\nweb). Oddly enough, until recently, the only established framework that\nproduced UPLC from a high-level syntax was called 'Plutus-Tx' and\nhappened to be a Haskell framework.\nOpShin changes the game by introducing a new framework that compiles\nstraight to UPLC.\nCan I write off-chain/backend code with OpShin?\nNo, but you can use the off-chain library PyCardano\nwith which OpShin is closely integrated!\nIn PyCardano, you can natively import and handle the functions and classes you defined for your contract -\nthis lets you build off-chain code that matches the contract frictionless.\nThe OpShin Starter Kit provides a practical example\non how to use PyCardano and OpShin in symbiosis."}},"/user-manual/language_tour/variables":{"title":"Variables","data":{"":"Variables in Opshin are declared just like you'd expect them to in Python:\n# A simple variable declaration\nx = 5 \n# A variable declaration with annotated type, x must be an integer\nx: int = 5 \n# Variables in Opshin can be mutated.\nx += 1\nNote: For now int is the only number type available in Opshin. fractions are coming soon.","type-annotation#Type annotation":"If you want to make sure that a variable has the type you expect it to have\nyou may use type annotation at the time of assinging a variable.\nx: int = some_function()\nThis will make sure that some_function actually returns an integer.Annotations can also be used for type up- and downcasts.\nFor example if you receive a value y of type Union[A, B] you can run\nz: A = y\nThis will cast y to type A in the type system but will not check the type\nduring runtime. Use with care.The other way around, if you receive a value of type A but you may want\nto use it as a Union[A, B] you can run\nz: Union[A, B] = y\nThis will allow you to also store objects of type B in z later in the code.\nNote that the type of a variable can not be changed after initialization.\nThis is true as of version 0.19.0 and may change again in a later version.","tuple-assignments#Tuple Assignments":"Opshin supports Python's tuple assignment syntax:\na, b = 3, 7"}},"/user-manual/smart_contract_tour/migration_v3":{"title":"Migrating to PlutusV3","data":{"":"If you previously wrote contracts in OpShin using PlutusV2 (version 0.26.1 or earlier), this guide helps you migrate to PlutusV3 (version 0.27.0 and later).","obtaining-datum-and-redeemer#Obtaining datum and redeemer":"The biggest change compared to PlutusV2 is, that all contracts (minting, spending, etc.) now expect only a single parameter, the Script Context.\nThe redeemer and datum are now stored inside the Script Context.Below is an example of how to modify your contract to quickly adapt to the new format. If your contract looked like this before...\ndef validator(datum: Listing, redeemer: ListingAction, context: ScriptContext) -> None:\n    ...\nYou can adapt it like this for the new PlutusV3 format.\ndef validator(context: ScriptContext) -> None:\n    datum: Listing = own_datum_unsafe(context)\n    redeemer: ListingAction = context.redeemer\n    ...\nFor non-spending contracts, you may want to skip the part regarding datum.","naming-changes-in-the-ledger-api#Naming changes in the ledger API":"Please inspect the ledger API for potential changes in the structure and names of Script Context fields.\nThe most common differences:\nScriptContext.tx_info is now called ScriptContext.transaction\nTxInfo.valid_range is now called TxInfo.validity_range","returning-none#Returning None":"PlutusV3 enforces that validators return BuiltinUnit. In OpShin, this corresponds to the Python value None, and is the default return value, for example if your contract does not end with a return statement. However, you need to make sure that the return value of the validator is annotated with -> None. Thus, the standard signature for any smart contract on PlutusV3 is now like this.\ndef validator(context: ScriptContext) -> None:","script-parameters#Script parameters":"If you previously paramterized your script, you need to now explicitly specify the number of left-over parameters of your contract after applying command-line arguments. For example, to create a minting contract that accepts a single bytes parameter with a validator like this:\n# validator.py\ndef validator(tk_name: bytes, context: ScriptContext) -> None:\n    ...\nYou need to compile it like this\nopshin build validator.py --parameters 1\nThis ensures that you do not run into unexpected runtime errors when you mistakenly still expect datum and redeemer parameters.If you already parameterize during building, you specify the number of left-over parameters, if any. For example for the following contract, where we bind the first two during building, we specify 1 as the number of left-over parameters.\n# validator2.py\ndef validator(owner: bytes, after: int, tk_name: bytes, context: ScriptContext) -> None:\n    ...\nopshin build validator2.py '{\"bytes\": \"DEADBEEF\"}' '{\"int\": 42}' --parameters 1","multi-purpose-contracts#Multi-purpose contracts":"By default, all contracts in PlutusV3 can act as multi-purpose contracts. The flag --force-three-params was removed.","new-builtins#New builtins":"The PlutusV3 language comes with a range of new builtins, in particular for bitwise manipulation and operations on the BLS 12 381 rings, enabling the verification of zero-knowledge proofs on-chain.\nYou can find more details about all builtins by inspecting the builtin library."}}}